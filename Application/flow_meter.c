/*
 * flow_meter.c
 * Implementation of Flow Meter Logic
 * Integrates: TI USS Library + Custom TIDA-01486 Booster Control
 */

#include "flow_meter.h"
#include <msp430.h>

// --- TI USS Library Headers ---
// These files are generated by USS Design Center or provided by TI.
#include "ussSwLib.h"
#include "uss_user_config.h" 

// --- Custom Hardware Drivers ---
#include "hal_booster.h" // Essential for TIDA-01486 Control

// --- Private Variables ---
static float last_flow_rate = 0.0f;
static float total_volume = 0.0f;

// TI USS Library Configuration Structure
static USS_SW_Library_configuration ussAlgoConfig; 

// Calibration Constant (Example: Depends on Pipe Diameter)
#define METER_CONSTANT 0.05f 

void Flow_Init(void) {
    // 1. Initialize TIDA-01486 Booster Hardware (Pins)
    HAL_Booster_Init();

    // 2. Initialize TI USS Software Library
    // Uses settings from uss_user_config.h
    uss_sw_lib_init(&ussAlgoConfig);
}

float Flow_Measure_LPH(void) {
    USS_Algorithms_Results algorithms_results;
    
    // --- STEP 1: WAKE UP BOOSTER (Active Path) ---
    // We must enable the TIDA-01486 analog front end before measuring.
    HAL_Booster_Control(BOOSTER_PAIR1_ACTIVE);

    // Small delay for Op-Amp stabilization (~800 cycles @ 8MHz = 100us)
    __delay_cycles(800); 
    
    // --- STEP 2: RUN MEASUREMENT ---
    // TI Library handles the firing sequence and capture
    // This function blocks execution for a few milliseconds
    USS_runAlgorithms(&ussAlgoConfig, &algorithms_results);

    // --- STEP 3: SLEEP BOOSTER (Power Save) ---
    // Measurement done, turn off the external amplifier to save battery
    HAL_Booster_Control(BOOSTER_SLEEP);

    // --- STEP 4: PROCESS RESULTS ---
    
    // Check for Measurement Errors (e.g., Signal weak, Air bubble)
    if (algorithms_results.messageCode != USS_message_code_no_error) {
        return -1.0f; // Error Code
    }

    // Convert Time of Flight (Delta ToF in picoseconds) to Flow Rate
    // Formula: Flow = dToF * K_Factor
    float dToF = algorithms_results.deltaTOF; 
    
    float current_lph = dToF * METER_CONSTANT;

    // Handle Negative Flow (Backflow) -> Take Absolute Value
    if (current_lph < 0) {
        current_lph = -current_lph; 
    }

    // Update Global Variables
    last_flow_rate = current_lph;
    
    // Accumulate Volume (Assuming 1 measurement per second)
    // LPH / 3600 = Liters per Second
    total_volume += (current_lph / 3600.0f);

    return last_flow_rate;
}

float Flow_GetLastRate(void) {
    return last_flow_rate;
}

float Flow_GetTotalVolume(void) {
    return total_volume;
}